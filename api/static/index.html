<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>StormEvents Map</title>
  <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    :root { --bar-h: 56px; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #map { width:100%; height: calc(100vh - var(--bar-h)); }
    .bar {
      height: var(--bar-h);
      display:flex; align-items:center; gap:10px; padding:8px 10px;
      border-bottom:1px solid #ddd; background:#fafafa; flex-wrap:wrap;
    }
    .legend { display:inline-flex; gap:14px; margin-left:6px; font-size:14px; }
    .key { display:inline-flex; align-items:center; gap:6px; }
    .swatch { width:12px; height:12px; border-radius:50%; display:inline-block; }
    input[type="date"], input[type="number"] { padding:3px 6px; }
    label { font-size:14px; }
    button { padding:4px 8px; }
    #status { font-size:13px; color:#374151; margin-left:6px; }
    .sep { width:1px; height:18px; background:#ddd; margin:0 6px; }
  </style>
</head>
<body>
  <div class="bar">
    <button id="ping">Ping API</button>
    <span id="status"></span>
    <div class="sep"></div>

    <label>Start <input id="start" type="date" /></label>
    <label>End <input id="end" type="date" /></label>
    <label>Limit <input id="limit" type="number" value="500" min="1" max="5000" style="width:72px"></label>
    <label><input id="useBounds" type="checkbox" /> Use map bounds</label>
    <label><input id="autoReload" type="checkbox" checked /> Auto reload on move</label>
    <button id="reload">Reload</button>
    <button id="download">Download CSV</button>

    <div class="sep"></div>

    <!-- Type filters -->
    <label><input class="flt" type="checkbox" data-bucket="Tornado" checked />
      <span class="swatch" style="background:#e11d48"></span> Tornado</label>
    <label><input class="flt" type="checkbox" data-bucket="Hail" checked />
      <span class="swatch" style="background:#16a34a"></span> Hail</label>
    <label><input class="flt" type="checkbox" data-bucket="Flood" checked />
      <span class="swatch" style="background:#2563eb"></span> Flood</label>
    <label><input class="flt" type="checkbox" data-bucket="Wind" checked />
      <span class="swatch" style="background:#f59e0b"></span> Wind</label>
  </div>

  <div id="map"></div>

  <script>
    // ==== CONFIG ====
    // When served by FastAPI StaticFiles, same-origin requests work, so base is "".
    const API = "";

    const TYPE_COLORS = { Tornado:'#e11d48', Hail:'#16a34a', Flood:'#2563eb', Wind:'#f59e0b' };
    const defaultColor = '#ef4444';

    // Map raw NOAA types to our 4 legend buckets
    const BUCKET_FOR = (t) => {
      switch (t) {
        case 'Tornado':
        case 'Waterspout': return 'Tornado';

        case 'Hail':
        case 'Marine Hail': return 'Hail';

        case 'Flood':
        case 'Flash Flood':
        case 'Heavy Rain': return 'Flood';

        case 'Thunderstorm Wind':
        case 'Marine Thunderstorm Wind':
        case 'High Wind':
        case 'Marine High Wind': return 'Wind';

        default: return null;
      }
    };

    // ==== MAP ====
    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://demotiles.maplibre.org/style.json',
      center: [-98.5795, 39.8283],
      zoom: 4
    });

    // ---- Ping ----
    document.getElementById('ping').onclick = async () => {
      try {
        const t0 = performance.now();
        const res = await fetch(`${API}/health`);
        const js = await res.json();
        const ms = Math.round(performance.now() - t0);
        document.getElementById('status').textContent = `Health OK in ${ms} ms â†’ ${JSON.stringify(js)}`;
      } catch {
        document.getElementById('status').textContent = 'Ping failed';
      }
    };

    // ---- helpers ----
    const debounce = (fn, ms=400) => {
      let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn(...args), ms); };
    };

    function selectedBuckets() {
      const set = new Set();
      document.querySelectorAll('.flt').forEach(cb => { if (cb.checked) set.add(cb.dataset.bucket); });
      return set;
    }

    // ---- UI -> query string ----
    function buildQuery() {
      const params = new URLSearchParams();
      const start = document.getElementById('start').value;
      const end = document.getElementById('end').value;
      const limit = document.getElementById('limit').value || '500';
      if (start) params.set('start', start);
      if (end) params.set('end', end);
      params.set('limit', limit);

      if (document.getElementById('useBounds').checked) {
        const b = map.getBounds();
        const bbox = [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()].join(',');
        params.set('bbox', bbox);
      }
      return params.toString();
    }

    let lastGeojson = { type:'FeatureCollection', features: [] };

    async function loadEvents() {
      const t0 = performance.now();
      const qs = buildQuery();
      const url = `${API}/events?${qs}`;
      console.log('[loadEvents] GET', url);
      const resp = await fetch(url);
      if (!resp.ok) {
        document.getElementById('status').textContent = `HTTP ${resp.status}`;
        return;
      }
      const data = await resp.json();
      const items = data.items || [];

      // Filter by bucket selection and build GeoJSON
      const allow = selectedBuckets();
      const features = items
        .filter(ev => Number.isFinite(+ev.lon) && Number.isFinite(+ev.lat))
        .map(ev => {
          const bucket = BUCKET_FOR(ev.type) || 'Wind';
          return {
            type: 'Feature',
            properties: {
              type: ev.type,
              bucket,
              date: ev.date || '',
              magnitude: ev.magnitude == null ? '' : ev.magnitude
            },
            geometry: { type: 'Point', coordinates: [+ev.lon, +ev.lat] }
          };
        })
        .filter(f => allow.has(f.properties.bucket));

      lastGeojson = { type: 'FeatureCollection', features };

      // Replace source/layers
      const layers = ['se-unclustered', 'se-clusters', 'se-cluster-count'];
      layers.forEach(id => { if (map.getLayer(id)) map.removeLayer(id); });
      if (map.getSource('se')) map.removeSource('se');

      map.addSource('se', {
        type: 'geojson',
        data: lastGeojson,
        cluster: true,
        clusterRadius: 40,
        clusterMaxZoom: 10
      });

      // Unclustered points (colored by bucket)
      map.addLayer({
        id: 'se-unclustered',
        type: 'circle',
        source: 'se',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-radius': 5,
          'circle-stroke-width': 1.2,
          'circle-stroke-color': '#fff',
          'circle-color': [
            'match', ['get', 'bucket'],
            'Tornado', '#e11d48',
            'Hail',    '#16a34a',
            'Flood',   '#2563eb',
            'Wind',    '#f59e0b',
            '#ef4444'
          ]
        }
      });

      // Cluster bubbles
      map.addLayer({
        id: 'se-clusters',
        type: 'circle',
        source: 'se',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': [
            'step', ['get', 'point_count'],
            '#a7f3d0', 50,
            '#60a5fa', 200,
            '#fb923c'
          ],
          'circle-radius': [
            'step', ['get', 'point_count'],
            14, 50, 18, 200, 24
          ],
          'circle-stroke-width': 1.2,
          'circle-stroke-color': '#fff'
        }
      });

      // Cluster counts
      map.addLayer({
        id: 'se-cluster-count',
        type: 'symbol',
        source: 'se',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': ['get', 'point_count_abbreviated'],
          'text-size': 12
        },
        paint: { 'text-color': '#0f172a' }
      });

      // Interactions
      map.on('click', 'se-clusters', (e) => {
        const f = e.features?.[0];
        if (!f) return;
        map.getSource('se').getClusterExpansionZoom(
          f.properties.cluster_id,
          (err, zoom) => {
            if (err) return;
            map.easeTo({ center: f.geometry.coordinates, zoom });
          }
        );
      });
      map.on('mouseenter', 'se-clusters', () => map.getCanvas().style.cursor = 'pointer');
      map.on('mouseleave', 'se-clusters', () => map.getCanvas().style.cursor = '');

      map.on('click', 'se-unclustered', (e) => {
        const f = e.features?.[0];
        if (!f) return;
        const p = f.properties;
        new maplibregl.Popup({ offset: 10 })
          .setLngLat(f.geometry.coordinates)
          .setHTML(`<b>${p.type}</b><br>${p.date || ''}${p.magnitude ? `<br>Mag: ${p.magnitude}`:''}`)
          .addTo(map);
      });

      // Fit bounds
      const b = new maplibregl.LngLatBounds();
      features.forEach(f => b.extend(f.geometry.coordinates));
      if (!b.isEmpty()) map.fitBounds(b, { padding: 40, maxZoom: 6 });

      const ms = Math.round(performance.now() - t0);
      document.getElementById('status').textContent = `Plotted ${features.length} events (clustered) in ${ms} ms`;
      console.log('[loadEvents] plotted:', features.length);
    }

    async function loadSummary() {
      try {
        const params = new URLSearchParams({ groupby: 'type' });
        const start = document.getElementById('start').value;
        const end   = document.getElementById('end').value;
        if (start) params.set('start', start);
        if (end)   params.set('end', end);
        const res = await fetch(`${API}/events/summary?` + params.toString());
        if (!res.ok) return;
        const js = await res.json();
        // Write counts into the label text (small UI sugar)
        const counts = Object.fromEntries((js.items||[]).map(r => [r.key, r.n]));
        document.querySelectorAll('.flt').forEach(cb => {
          const bucket = cb.dataset.bucket;
          const label = cb.parentElement;
          const n = counts[bucket] || 0;
          label.title = `${bucket}: ${n.toLocaleString()}`;
        });
      } catch {}
    }

    // ---- Download CSV of current query (unfiltered by checkboxes on the client) ----
    document.getElementById('download').onclick = async () => {
      const qs = buildQuery();
      const url = `${API}/events?${qs}`;
      const res = await fetch(url);
      const js  = await res.json();
      const items = js.items || [];
      const cols = ['event_id','type','magnitude','lon','lat','date'];
      const csv  = [cols.join(',')]
        .concat(items.map(r => cols.map(k => {
          const v = r[k] == null ? '' : r[k];
          // simple CSV escaping
          return /[",\n]/.test(String(v)) ? `"${String(v).replace(/"/g,'""')}"` : String(v);
        }).join(',')))
        .join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'stormevents.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    // ---- Defaults & wiring ----
    map.on('load', () => {
      const s = document.getElementById('start');
      const e = document.getElementById('end');
      if (!s.value) s.value = '2023-01-01';
      if (!e.value) e.value = '2023-12-31';
      loadEvents();
      loadSummary();
    });

    const reloadAll = () => { loadEvents(); loadSummary(); };
    const reloadDebounced = debounce(reloadAll, 450);

    document.getElementById('reload').onclick = reloadAll;
    document.getElementById('useBounds').onchange = reloadAll;
    document.querySelectorAll('.flt').forEach(cb => cb.onchange = () => {
      // re-apply client filter without a network call when possible
      const allow = selectedBuckets();
      if (map.getSource('se')) {
        const filtered = {
          type: 'FeatureCollection',
          features: (lastGeojson.features||[]).filter(f => allow.has(f.properties.bucket))
        };
        map.getSource('se').setData(filtered);
      }
    });

    map.on('moveend', () => {
      if (document.getElementById('useBounds').checked &&
          document.getElementById('autoReload').checked) {
        reloadDebounced();
      }
    });
  </script>
</body>
</html>
